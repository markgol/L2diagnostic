//--------------------------------------------------------
//
//  L2Diagnostic
//  Author: Mark Stegall
//  Module: MainWindow.cpp
//
//  Purpose:
//  Determine correct operation of the Unitreee L2 Lidar hardware
//  and software.  Establish platform independent software protocols
//  for using the L2 Lidar with its Ethernet interface.
//
//  Background:
//  Unitree provides undoucmented software files in the form:
//      include files
//      example application files
//      .a Archive Library
//
//  The source files rely on an Archive library using POSIX I/O
//  No source exists for the archive Library making it diffcult
//  to debug or port usage of the L2 Lidar for other platforms.
//  The hardware has 2 mutually exclusive communication interfaces:
//      Ethernet using UDP
//      Serial UART
//  The serial UART is limited in speed and does not operate at
//  the full sensor speed of 64K/sec sample points.
//
//  Solution:
//  This software skeleton was created using directed ChatGPT AI
//  conversation targetting a QT Creator development platform.
//  It reads UPD packets from the L2, caterorizes them, performs
//  error detection for bad packets (lost), display subsample
//  of packets and optionally saves them to a CSV file.
//
//  V0.1.0  2025-12-27  compilable skeleton created by ChatGPT
//  V0.2.0  2026-01-02  Documentation, start of debugging
//  V0.2.1  2026-01-05  Changed LidarDecoder.h and cpp to L2lidar
//                      Changed class name from LidarDecoder to L2lidar
//                      Added L2 information to GUI
//                      Added L2 start rotation, stop rotation,
//                              reset and get Version info buttons
//                      Changed config dialog
//                          for src and dest ip, port
//                      Updated @notes for unitree_lidar_protocols.h
//  V0.2.2  2026-01-07  Added ACK packets decodes to ui
//          2026-01-08  Added Mutex access to packet copies
//                      Added 3d point packet to 3d PCL cloud conversion
//                          to demonstrate packets are being received
//                          and processed correctly
//
//--------------------------------------------------------

//--------------------------------------------------------
// This uses the following Unitree L2 sources modules:
//      unitree_lidar_protocol.h
//      unitree_lidar_utilities
// The orignal source can be found at:
//      https://github.com/unitreerobotics/unilidar_sdk2
//      under License: BSD 3-Clause License (see files)
//
// Corrections/additions have been made to these 2 files
//--------------------------------------------------------

//--------------------------------------------------------
// GPL-3.0 license
//
// This file is part of L2diagnsotic.
//
// L2diagnsotic is free software : you can redistribute it and /or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// L2diagnsotic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with L2diagnsotic.
// If not, see < https://www.gnu.org/licenses/>.
//--------------------------------------------------------


//--------------------------------------------------------
// Main project includes required before anything else
//--------------------------------------------------------
#include "MainWindow.h"
#include "unitree_lidar_protocol.h"
#include "unitree_lidar_utilities.h"

//--------------------------------------------------------
// Autogenerated Qt desktop GUIM include
// This is generated from the MainWindow.ui file
// The CMakeFIle.txt must include:
//      set(CMAKE_AUTOMOC ON)
//      set(CMAKE_AUTOUIC ON)
//      set(CMAKE_AUTORCC ON)
//--------------------------------------------------------
#include "ui_MainWindow.h"

//--------------------------------------------------------
//  Qt includes
//--------------------------------------------------------
#include <QHostAddress>
#include <QDateTime>
#include <QSettings>
#include <QStandardPaths>
#include <QDebug>

//--------------------------------------------------------
//  Project specific includes not part of MainWindow.h
//--------------------------------------------------------
#include "ConfigDialog.h"

//--------------------------------------------------------
//  MainWIndow class constructor
//--------------------------------------------------------
MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // Instantiated the GUI elements

    // GUI utlizes the chart timer to update the GUI
    // from stored memory so that it does not block I/O

    // Setup chart GUI elements
    auto chart = new QChart();
    rateSeries = new QLineSeries();
    chart->addSeries(rateSeries);

    auto axisX = new QValueAxis();
    auto axisY = new QValueAxis();
    axisX->setRange(0, 100); // 100 smaples
    axisY->setRange(0, 1000); // 0-1000 packets per second
    chart->addAxis(axisX, Qt::AlignBottom);
    chart->addAxis(axisY, Qt::AlignLeft);
    rateSeries->attachAxis(axisX);
    rateSeries->attachAxis(axisY);

    auto chartView = new QChartView(chart);
    chartView->setRenderHint(QPainter::Antialiasing);
    ui->verticalLayout->addWidget(chartView);

    // Chart update timer
    // The chart timer is started/stopped by start and stop GUI buttons
    connect(&chartTimer, &QTimer::timeout, this, &MainWindow::updateChart);

    // Connect UI buttons
    // Do NOT bind socket or start timer here
    ui->btnStart->setEnabled(true);
    ui->btnStop->setEnabled(false);
    ui->btnStartRotation->setEnabled(false);
    ui->btnStopRotation->setEnabled(false);
    ui->btnResetL2->setEnabled(false);
    ui->btnVersion->setEnabled(false);
    connect(ui->btnStart, &QPushButton::clicked, this, &MainWindow::L2connect);
    connect(ui->btnStop, &QPushButton::clicked, this, &MainWindow::L2disconnect);
    connect(ui->btnConfig, &QPushButton::clicked, this, &MainWindow::openConfig);

    connect(ui->btnStartRotation, &QPushButton::clicked, this, &MainWindow::startRotation);
    connect(ui->btnStopRotation, &QPushButton::clicked, this, &MainWindow::stopRotation);
    connect(ui->btnResetL2, &QPushButton::clicked, this, &MainWindow::sendReset);
    connect(ui->btnVersion, &QPushButton::clicked, this, &MainWindow::getVersion);

    // Lidar UPD decoder callbacks

    // ACK handling optional for now
    //lidarDecoder.onAck([](const uint8_t*) {});

    // IMU handling later
    //lidarDecoder.onImu([](const uint8_t*) {});

    // Point data handling later
    //lidarDecoder.onPointData([](const uint8_t*) {});


    // Load previously saved user settings
    loadSettings();
    l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                              config.getDSTip(),config.getDSTport());
}

//--------------------------------------------------------
//  MainWIndow class destructor
//--------------------------------------------------------
MainWindow::~MainWindow()
{
    // Make sure live capture is stopped
    L2disconnect();

    // close the CSV file output if required
    if (csvFile.isOpen()) csvFile.close();

    // Save current user settings
    saveSettings();

    delete ui;
}

//--------------------------------------------------------
//  openConfig
//  open the configuration dialog to allow the user to change
//  application settings.
//--------------------------------------------------------
void MainWindow::openConfig()
{
    if (config.exec() == QDialog::Accepted) {
        l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                                  config.getDSTip(),config.getDSTport());
        saveSettings();
    }
}

//--------------------------------------------------------
//  L2connect()
//--------------------------------------------------------
void MainWindow::L2connect()
{
    //
    if(!l2lidar.ConnectL2()) {
        qWarning() << "Failed: coudl open open communications port to L2";
        return;
    }

    // CSV setup
    // ??? this still to be implemented
    // This is placeholder reminder
    if (config.csvEnabled()) {
        QString filename = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss") + "_log.csv";
        csvFile.setFileName(filename);
        if (csvFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            csvStream.setDevice(&csvFile);
            csvStream << "Timestamp,Value\n";
        } else {
            qWarning() << "Failed to open CSV file:" << filename;
        }
    }

    LastRateCount = 0; // reset rate count

    // Start chart timer
    chartTimer.start(CHART_UPDATE_TIMER);

    // disable start, enable stop
    ui->btnStart->setEnabled(false);
    ui->btnStop->setEnabled(true);
    ui->btnStartRotation->setEnabled(true);
    ui->btnStopRotation->setEnabled(true);
    ui->btnResetL2->setEnabled(true);
    ui->btnVersion->setEnabled(true);
}

//--------------------------------------------------------
//  L2disconnect()
//--------------------------------------------------------
void MainWindow::L2disconnect()
{
    chartTimer.stop();

    // close UDP connection for receiving data
    l2lidar.DisconnectL2();

    if (csvFile.isOpen()) csvFile.close();

    l2lidar.ClearCounts();
    recentRates.clear(); // clear the rate history

    ui->btnStart->setEnabled(true);
    ui->btnStop->setEnabled(false);
    ui->btnStartRotation->setEnabled(false);
    ui->btnStopRotation->setEnabled(false);
    ui->btnResetL2->setEnabled(false);
    ui->btnVersion->setEnabled(false);

}

//--------------------------------------------------------
//  updateChart()
//  update the user GUI with latest I/O results
//--------------------------------------------------------
void MainWindow::updateChart()
{
    // update detailed packet stats
    uint64_t countPackets = l2lidar.totalPackets();
    uint64_t lostPackets = l2lidar.lostPackets();
    uint64_t count3DPCL = l2lidar.total3D();
    uint64_t count2DPCL = l2lidar.total2D();
    uint64_t countIMU = l2lidar.totalIMU();
    uint64_t countACK = l2lidar.totalACK();
    uint64_t countOther = l2lidar.totalOther();
    LidarVersionData Version = l2lidar.version();

    LidarAckData ACKdata = l2lidar.ack();
    LidarPointDataPacket PCLpacket = l2lidar.Pcl3Dpacket();
    LidarImuData IMUdata = l2lidar.imu();

    uint64_t RateCount;
    uint64_t RatePerSec;

    // update the packet rate chart

    // calculate packets per second
    RateCount = countPackets;
    // ??? save the timestamp with each rate sample
    //  calculate rate using delta timestamp
    // this would result in a rate not subject to GUI interactions
    RatePerSec = (RateCount - LastRateCount)*1000/CHART_UPDATE_TIMER;
    LastRateCount = RateCount; // save for next timer timer

    // save RatesPerSec for graph
    recentRates.push_back(RatePerSec);
    if (recentRates.size() > maxPoints)
        recentRates.pop_front();

    rateSeries->clear();
    int x = 0;
    for (auto value : recentRates)
        rateSeries->append(x++, static_cast<qreal>(value));

    // update general packet stats
    ui->lblRate->setText(QString("Rate: %1 pkt/s").arg(RatePerSec));

    // update the hw/fw verion infor

    // update Version information if present
    QString HWversion = QString().asprintf("%d.%d.%d.%d",
                                           Version.hw_version[0],
                                           Version.hw_version[1],
                                           Version.hw_version[2],
                                           Version.hw_version[3]);
    QString FWversion = QString().asprintf("%d.%d.%d.%d",
                                           Version.sw_version[0],
                                           Version.sw_version[1],
                                           Version.sw_version[2],
                                           Version.sw_version[3]);
    QString BuildDate = QString().asprintf("20%c%c-%c%c-%c%c",
                                           Version.date[0],
                                           Version.date[1],
                                           Version.date[2],
                                           Version.date[3],
                                           Version.date[4],
                                           Version.date[5]);

    QString Product = QString::fromUtf8((const char *)Version.reserve);

    ui->lblVersion->setText(QString("%1  HW Version: %2   FW Version: %3   Date: %4")
                            .arg(Product,HWversion, FWversion,BuildDate));

    // report the last ACK packet result
    if(ACKdata.packet_type!=0) {
        QString ACKstring = ACKreport(&ACKdata);
        ui->lblACK->setText(ACKstring);
    }

    // report the IMU packet results
    if(IMUdata.info.stamp.nsec!=0) {
        QString IMUstring = IMUreport(&IMUdata);
        ui->lblIMU->setText(IMUstring);
    }

    // report the PCL data
    if(PCLpacket.data.info.stamp.nsec!=0) {
        QString PCLstring = PCLreport(PCLpacket);
        ui->lblPCL->setText(PCLstring);
    }

    // get latest time stamp for UDP data
    LidarTimeStampData TimeStamp = l2lidar.timestamp();

    QString PacketStats = QString().asprintf("Seconds:%6llu   nsec:%9llu    Packets Processed:%6llu  3D PCL:%6llu   2d PCL:%6llu   IMU:%6llu   ACK:%6llu   Other:%6llu   Lost:%6llu",
                                              TimeStamp.data.sec,
                                              TimeStamp.data.nsec,
                                              countPackets,
                                              count3DPCL,
                                              count2DPCL,
                                              countIMU,
                                              countACK,
                                              countOther,
                                              lostPackets);
    ui->lblPacketStats->setText(PacketStats);
}

//--------------------------------------------------------
// startRotation
//--------------------------------------------------------
void MainWindow::startRotation()
{
    l2lidar.LidarStartRotation();
    return;
}

//--------------------------------------------------------
// stopRotation
//--------------------------------------------------------
void MainWindow::stopRotation()
{
    l2lidar.LidarStopRotation();
    return;
}

//--------------------------------------------------------
// sendReset
//--------------------------------------------------------
void MainWindow::sendReset()
{
    l2lidar.LidarReset();
    return;
}

//--------------------------------------------------------
// getVersion
//--------------------------------------------------------
void MainWindow::getVersion()
{
    l2lidar.LidarGetVersion();
    return;
}


//--------------------------------------------------------
// ACKreport
// reports ACK packet decode
// note: there are certain ACK packets that should never occur
// but are included here for completeness
// There is insufficient documenation to properly identify these
//--------------------------------------------------------
QString MainWindow::ACKreport(LidarAckData *ACKdata)
{
    QString ACKstring;
    QString Packet;
    QString Result;

    // The LidarAckData packet is supposed to provide
    // the acknowledgement of a control/query cmd sent to
    // L2 unit.  It primary purpose is to provide success or failure
    // in receiving the control/query cmd.
    //
    // It should be noted that there are discrepancies in the other
    // return values in this packet were is may not provide the
    // correct packet type, cmd type or value.  THese values should
    // not be relied upon without verfication of correct reporting
    // specifically for that command
    //
    // In at least one instance no ACK packet will be return.
    // This is for a reset a L2 command

    switch(ACKdata->packet_type) {
    case LIDAR_USER_CMD_PACKET_TYPE:
        switch(ACKdata->cmd_type) {
        case USER_CMD_RESET_TYPE:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_RESET_TYPE  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_STANDBY_TYPE:   // value 0: start; value 1: standby
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_STANDBY_TYPE  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_VERSION_GET:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_VERSION_GET  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_LATENCY_TYPE:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_LATENCY_TYPE  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_CONFIG_RESET:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_CONFIG_RESET  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_CONFIG_GET:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_CONFIG_GET  value: %1").arg(ACKdata->cmd_value);
            break;
        case USER_CMD_CONFIG_AUTO_STANDBY:
            Packet = QString("ACK: LIDAR_USER_CMD_PACKET_TYPE: USER_CMD_CONFIG_AUTO_STANDBY  value: %1").arg(ACKdata->cmd_value);
            break;
        default:
            Packet = QString("ACK :LIDAR_USER_CMD_PACKET_TYPE:  cmd: %1   value: %2").arg(ACKdata->cmd_type,ACKdata->cmd_value);
            break;
        }
        break;

    case LIDAR_ACK_DATA_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_ACK_DATA_PACKET_TYPE:  cmd: %1  value:%2  UNEXPECTED packet")
                         .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_POINT_DATA_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_POINT_DATA_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_2D_POINT_DATA_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_2D_POINT_DATA_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_IMU_DATA_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_IMU_DATA_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_VERSION_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_VERSION_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_TIME_STAMP_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_TIME_STAMP_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_WORK_MODE_CONFIG_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_WORK_MODE_CONFIG_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_IP_ADDRESS_CONFIG_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_IP_ADDRESS_CONFIG_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_MAC_ADDRESS_CONFIG_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_MAC_ADDRESS_CONFIG_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    case LIDAR_COMMAND_PACKET_TYPE:
        switch(ACKdata->cmd_type) {
            case CMD_RESET_TYPE:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_RESET_TYPE  value:%1")
                                 .arg(ACKdata->cmd_value);
                break;

            case CMD_PARAM_SAVE:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_PARAM_SAVE  value:%1")
                             .arg(ACKdata->cmd_value);
                break;

            case CMD_PARAM_GET:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_PARAM_GET  value:%1")
                             .arg(ACKdata->cmd_value);
                break;

            case CMD_VERSION_GET:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_VERSION_GET  value:%1")
                             .arg(ACKdata->cmd_value);
                break;

            case CMD_STANDBY_TYPE:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_STANDBY_TYPE  value:%1")
                             .arg(ACKdata->cmd_value);
                break;

            case CMD_LATENCY_TYPE:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: CMD_LATENCY_TYPE  value:%1")
                             .arg(ACKdata->cmd_value);
                break;

            case CMD_CONFIG_RESET:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE cmd: CMD_CONFIG_RESET  value:%1")
                             .arg(ACKdata->cmd_value);
            break;

        default:
                Packet = QString("ACK: LIDAR_COMMAND_PACKET_TYPE  cmd: %1  value:%2")
                             .arg(ACKdata->cmd_type, ACKdata->cmd_value);
            break;
        }
        break;

    case LIDAR_PARAM_DATA_PACKET_TYPE:
        Packet = QString("ACK: LIDAR_PARAM_DATA_PACKET_TYPE:  cmd: %1  value:%2")
                     .arg(ACKdata->cmd_type,ACKdata->cmd_value);
        break;

    default:
        // unkown type
        Packet = QString("ACK: problem unknown packet type: %1  cmd: %2  value:%3")
                         .arg(ACKdata->packet_type,ACKdata->cmd_value,ACKdata->cmd_value);
        break;
    }

    // ACKdata.status
    switch(ACKdata->status) {
    case ACK_SUCCESS:
        Result = "ACK_SUCCESS";
        break;

    case ACK_CRC_ERROR:
        Result = "";
        break;

    case ACK_HEADER_ERROR:
        Result = "ACK_CRC_ERROR";
        break;

    case ACK_BLOCK_ERROR:
        Result = "ACK_BLOCK_ERROR";
        break;

    case ACK_WAIT_ERROR:
        Result = "ACK_WAIT_ERROR";
        break;

    default:
        Result = "Unknown status";
        break;
    }

    return QString("%1   %2").arg(Packet,Result);
}

//--------------------------------------------------------
// IMUreport()
//--------------------------------------------------------
QString MainWindow::IMUreport(LidarImuData *IMUdata)
{
    QString Packet;
    Packet = Packet.asprintf("IMU: ax:%9.4f   ay:%9.4f   az:%9.4f  gx:%9.4f   gy:%9.4f  gz:%9.4f",
                             IMUdata->linear_acceleration[0],
                             IMUdata->linear_acceleration[1],
                             IMUdata->linear_acceleration[2],
                             IMUdata->angular_velocity[0],
                             IMUdata->angular_velocity[1],
                             IMUdata->angular_velocity[2]
                             );

    return Packet;
}
//LidarPointData
//--------------------------------------------------------
// IMUreport()
//--------------------------------------------------------
QString MainWindow::PCLreport(const LidarPointDataPacket &PCLdataPacket)
{
    QString Packet;

    // convert to point cloud data: x,y,z,intensity,time
    // This uses the unitree provided parseFromPacketToPointCloud()
    unilidar_sdk2::PointCloudUnitree Cloud;
    unilidar_sdk2::parseFromPacketToPointCloud( Cloud, PCLdataPacket, false, 0, 100);

    Packet = Packet.asprintf("Num Points %5d : %7.2f,%7.2f,%7.2f:%1.1f    %7.2f,%7.2f,%7.2f:%6.1f",
                             Cloud.points.size(),
                             Cloud.points[0].x,
                             Cloud.points[0].y,
                             Cloud.points[0].z,
                             Cloud.points[0].intensity,
                             Cloud.points[1].x,
                             Cloud.points[1].y,
                             Cloud.points[1].z,
                             Cloud.points[1].intensity
                             );
    return Packet;
}

//--------------------------------------------------------
// saveCsv()
// ??? This will need updating
//--------------------------------------------------------
void MainWindow::saveCsv(const QByteArray& datagram)
{
    // ??? this needs to be moved the the l2lidar
    // if (!csvFile.isOpen()) return;

    // PacketData packet = PacketData::fromDatagram(datagram);
    // QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss.zzz");
    // csvStream << timestamp << "," << "," << packet.value << "\n";
    // csvStream.flush();
}
