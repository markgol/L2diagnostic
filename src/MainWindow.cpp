//--------------------------------------------------------
//
//  L2Diagnostic
//  Author: Mark Stegall
//  Module: MainWindow.cpp
//
//  Purpose:
//  Determine correct operation of the Unitreee L2 Lidar hardware
//  and software.  Establish platform independent software protocols
//  for using the L2 Lidar with its Ethernet interface.
//
//  Background:
//  Unitree provides undoucmented software files in the form:
//      include files
//      example application files
//      .a Archive Library
//
//  The source files rely on an Archive library using POSIX I/O
//  No source exists for the archive Library making it diffcult
//  to debug or port usage of the L2 Lidar for other platforms.
//  The hardware has 2 mutually exclusive communication interfaces:
//      Ethernet using UDP
//      Serial UART
//  The serial UART is limited in speed and does not operate at
//  the full sensor speed of 64K/sec sample points.
//
//  Solution:
//  This software skeleton was created using directed ChatGPT AI
//  conversation targetting a QT Creator development platform.
//  It reads UPD packets from the L2, caterorizes them, performs
//  error detection for bad packets (lost), display subsample
//  of packets and optionally saves them to a CSV file.
//
//  V0.1.0  2025-12-27  compilable skeleton created by ChatGPT
//  V0.2.0  2026-01-02  Documentation, start of debugging
//  V0.2.1  2026-01-05  Changed LidarDecoder.h and cpp to L2lidar
//                      Changed class name from LidarDecoder to L2lidar
//                      Added L2 information to GUI
//                      Added L2 start rotation, stop rotation,
//                              reset and get Version info buttons
//                      Changed config dialog
//                          for src and dest ip, port
//                      Updated @notes for unitree_lidar_protocols.h
//
//--------------------------------------------------------

//--------------------------------------------------------
// This uses the following Unitree L2 sources modules:
//      unitree_lidar_protocol.h
//      unitree_lidar_utilities
// The orignal source can be found at:
//      https://github.com/unitreerobotics/unilidar_sdk2
//      under License: BSD 3-Clause License (see files)
//
// Corrections/additions have been made to these 2 files
//--------------------------------------------------------

//--------------------------------------------------------
// GPL-3.0 license
//
// This file is part of L2diagnsotic.
//
// L2diagnsotic is free software : you can redistribute it and /or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// L2diagnsotic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with L2diagnsotic.
// If not, see < https://www.gnu.org/licenses/>.
//--------------------------------------------------------


//--------------------------------------------------------
// Main project includes required before anything else
//--------------------------------------------------------
#include "MainWindow.h"

//--------------------------------------------------------
// Autogenerated Qt desktop GUIM include
// This is generated from the MainWindow.ui file
// The CMakeFIle.txt must include:
//      set(CMAKE_AUTOMOC ON)
//      set(CMAKE_AUTOUIC ON)
//      set(CMAKE_AUTORCC ON)
//--------------------------------------------------------
#include "ui_MainWindow.h"

//--------------------------------------------------------
//  Qt includes
//--------------------------------------------------------
#include <QHostAddress>
#include <QDateTime>
#include <QSettings>
#include <QStandardPaths>
#include <QDebug>

//--------------------------------------------------------
//  Project specific includes not part of MainWindow.h
//--------------------------------------------------------
#include "ConfigDialog.h"

//--------------------------------------------------------
//  MainWIndow class constructor
//--------------------------------------------------------
MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // Instantiated the GUI elements

    // GUI utlizes the chart timer to update the GUI
    // from stored memory so that it does not block I/O

    // Setup chart GUI elements
    auto chart = new QChart();
    rateSeries = new QLineSeries();
    chart->addSeries(rateSeries);

    auto axisX = new QValueAxis();
    auto axisY = new QValueAxis();
    axisX->setRange(0, 100); // 100 smaples
    axisY->setRange(0, 1000); // 0-1000 packets per second
    chart->addAxis(axisX, Qt::AlignBottom);
    chart->addAxis(axisY, Qt::AlignLeft);
    rateSeries->attachAxis(axisX);
    rateSeries->attachAxis(axisY);

    auto chartView = new QChartView(chart);
    chartView->setRenderHint(QPainter::Antialiasing);
    ui->verticalLayout->addWidget(chartView);

    // Chart update timer
    // The chart timer is started/stopped by start and stop GUI buttons
    connect(&chartTimer, &QTimer::timeout, this, &MainWindow::updateChart);

    // Connect UI buttons
    // Do NOT bind socket or start timer here
    ui->btnStart->setEnabled(true);
    ui->btnStop->setEnabled(false);
    ui->btnStartRotation->setEnabled(false);
    ui->btnStopRotation->setEnabled(false);
    ui->btnResetL2->setEnabled(false);
    ui->btnVersion->setEnabled(false);
    connect(ui->btnStart, &QPushButton::clicked, this, &MainWindow::L2connect);
    connect(ui->btnStop, &QPushButton::clicked, this, &MainWindow::L2disconnect);
    connect(ui->btnConfig, &QPushButton::clicked, this, &MainWindow::openConfig);

    connect(ui->btnStartRotation, &QPushButton::clicked, this, &MainWindow::startRotation);
    connect(ui->btnStopRotation, &QPushButton::clicked, this, &MainWindow::stopRotation);
    connect(ui->btnResetL2, &QPushButton::clicked, this, &MainWindow::sendReset);
    connect(ui->btnVersion, &QPushButton::clicked, this, &MainWindow::getVersion);

    // Lidar UPD decoder callbacks

    // ACK handling optional for now
    //lidarDecoder.onAck([](const uint8_t*) {});

    // IMU handling later
    //lidarDecoder.onImu([](const uint8_t*) {});

    // Point data handling later
    //lidarDecoder.onPointData([](const uint8_t*) {});


    // Load previously saved user settings
    loadSettings();
    l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                              config.getDSTip(),config.getDSTport());
}

//--------------------------------------------------------
//  MainWIndow class destructor
//--------------------------------------------------------
MainWindow::~MainWindow()
{
    // Make sure live capture is stopped
    L2disconnect();

    // close the CSV file output if required
    if (csvFile.isOpen()) csvFile.close();

    // Save current user settings
    saveSettings();

    delete ui;
}

//--------------------------------------------------------
//  openConfig
//  open the configuration dialog to allow the user to change
//  application settings.
//--------------------------------------------------------
void MainWindow::openConfig()
{
    if (config.exec() == QDialog::Accepted) {
        l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                                  config.getDSTip(),config.getDSTport());
        saveSettings();
    }
}

//--------------------------------------------------------
//  L2connect()
//--------------------------------------------------------
void MainWindow::L2connect()
{
    //
    if(!l2lidar.ConnectL2()) {
        qWarning() << "Failed: coudl open open communications port to L2";
        return;
    }

    // CSV setup
    // ??? this still to be implemented
    // This is placeholder reminder
    if (config.csvEnabled()) {
        QString filename = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss") + "_log.csv";
        csvFile.setFileName(filename);
        if (csvFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            csvStream.setDevice(&csvFile);
            csvStream << "Timestamp,Value\n";
        } else {
            qWarning() << "Failed to open CSV file:" << filename;
        }
    }

    LastRateCount = 0; // reset rate count

    // Start chart timer
    chartTimer.start(CHART_UPDATE_TIMER);

    // disable start, enable stop
    ui->btnStart->setEnabled(false);
    ui->btnStop->setEnabled(true);
    ui->btnStartRotation->setEnabled(true);
    ui->btnStopRotation->setEnabled(true);
    ui->btnResetL2->setEnabled(true);
    ui->btnVersion->setEnabled(true);
}

//--------------------------------------------------------
//  L2disconnect()
//--------------------------------------------------------
void MainWindow::L2disconnect()
{
    chartTimer.stop();

    // close UDP connection for receiving data
    l2lidar.DisconnectL2();

    if (csvFile.isOpen()) csvFile.close();

    l2lidar.ClearCounts();
    recentRates.clear(); // clear the rate history

    ui->btnStart->setEnabled(true);
    ui->btnStop->setEnabled(false);
    ui->btnStartRotation->setEnabled(false);
    ui->btnStopRotation->setEnabled(false);
    ui->btnResetL2->setEnabled(false);
    ui->btnVersion->setEnabled(false);

}

//--------------------------------------------------------
//  updateChart()
//  update the user GUI with latest I/O results
//   This includes:
//      Communication stats:
//          Packet data rate
//          Packet loss
//          Packets counts
//      Sensor information:
//          Firmware version
//          Hardware version
//          last Timestamp
//--------------------------------------------------------
void MainWindow::updateChart()
{
    // update detailed packet stats
    uint64_t countPackets = l2lidar.totalPackets();
    uint64_t lostPackets = l2lidar.lostPackets();
    uint64_t count3DPCL = l2lidar.total3D();
    uint64_t count2DPCL = l2lidar.total2D();
    uint64_t countIMU = l2lidar.totalIMU();
    uint64_t countACK = l2lidar.totalACK();
    uint64_t countOther = l2lidar.totalOther();
    LidarVersionData Version = l2lidar.version();

    uint64_t RateCount;
    uint64_t RatePerSec;

    // calculate packets per second
    RateCount = countPackets;
    RatePerSec = (RateCount - LastRateCount)*1000/CHART_UPDATE_TIMER;
    LastRateCount = RateCount; // save for next timer timer

    // save RatesPerSec for graph
    recentRates.push_back(RatePerSec);
    if (recentRates.size() > maxPoints)
        recentRates.pop_front();

    rateSeries->clear();
    int x = 0;
    for (auto value : recentRates)
        rateSeries->append(x++, static_cast<qreal>(value));

    // update general packet stats
    ui->lblRate->setText(QString("Rate: %1 pkt/s").arg(RatePerSec));

    // update Version information if present
    QString HWversion = QString().asprintf("%d.%d.%d.%d",
                                           Version.hw_version[0],
                                           Version.hw_version[1],
                                           Version.hw_version[2],
                                           Version.hw_version[3]);
    QString FWversion = QString().asprintf("%d.%d.%d.%d",
                                           Version.sw_version[0],
                                           Version.sw_version[1],
                                           Version.sw_version[2],
                                           Version.sw_version[3]);
    QString BuildDate = QString().asprintf("20%c%c-%c%c-%c%c",
                                           Version.date[0],
                                           Version.date[1],
                                           Version.date[2],
                                           Version.date[3],
                                           Version.date[4],
                                           Version.date[5]);

    QString Product = QString::fromUtf8((const char *)Version.reserve);

    ui->lblVersion->setText(QString("%1  HW Version: %2   FW Version: %3   Date: %4")
                            .arg(Product,HWversion, FWversion,BuildDate));

    // get current time stamp for UDP data
    LidarTimeStampData TimeStamp = l2lidar.timestamp();

    QString PacketStats = QString().asprintf("Seconds:%6llu   nsec:%9llu    Packets Processed:%6llu  3D PCL:%6llu   2d PCL:%6llu   IMU:%6llu   ACK:%6llu   Other:%6llu   Lost:%6llu",
                                              TimeStamp.data.sec,
                                              TimeStamp.data.nsec,
                                              countPackets,
                                              count3DPCL,
                                              count2DPCL,
                                              countIMU,
                                              countACK,
                                              countOther,
                                              lostPackets);
    ui->lblPacketStats->setText(PacketStats);
}

//--------------------------------------------------------
// startRotation
//--------------------------------------------------------
void MainWindow::startRotation()
{
    l2lidar.LidarStartRotation();
    return;
}

//--------------------------------------------------------
// stopRotation
//--------------------------------------------------------
void MainWindow::stopRotation()
{
    l2lidar.LidarStopRotation();
    return;
}

//--------------------------------------------------------
// sendReset
//--------------------------------------------------------
void MainWindow::sendReset()
{
    l2lidar.LidarReset();
    return;
}

//--------------------------------------------------------
// getVersion
//--------------------------------------------------------
void MainWindow::getVersion()
{
    l2lidar.LidarGetVersion();
    return;
}

//--------------------------------------------------------
// saveCsv()
// ??? This will need updating
//--------------------------------------------------------
void MainWindow::saveCsv(const QByteArray& datagram)
{
    // ??? this needs to be moved the the l2lidar
    // if (!csvFile.isOpen()) return;

    // PacketData packet = PacketData::fromDatagram(datagram);
    // QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss.zzz");
    // csvStream << timestamp << "," << "," << packet.value << "\n";
    // csvStream.flush();
}
