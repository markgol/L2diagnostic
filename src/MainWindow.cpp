//--------------------------------------------------------
//
//  L2Diagnostic
//  Author: Mark Stegall
//  Module: MainWindow.cpp
//
//  Purpose:
//  Determine correct operation of the Unitreee L2 Lidar hardware
//  and software.  Establish platform independent software protocols
//  for using the L2 Lidar with its Ethernet interface.
//
//  Background:
//  Unitree provides undoucmented software files in the form:
//      include files
//      example application files
//      .a Archive Library
//
//  The source files rely on an Archive library using POSIX I/O
//  No source exists for the archive Library making it diffcult
//  to debug or port usage of the L2 Lidar for other platforms.
//  The hardware has 2 mutually exclusive communication interfaces:
//      Ethernet using UDP
//      Serial UART
//  The serial UART is limited in speed and does not operate at
//  the full sensor speed of 64K/sec sample points.
//
//  Solution:
//  This software skeleton was created using directed ChatGPT AI
//  conversation targetting a QT Creator development platform.
//  It reads UPD packets from the L2, caterorizes them, performs
//  error detection for bad packets (lost), display subsample
//  of packets and optionally saves them to a CSV file.
//
//  V0.1.0  2025-12-27  compilable skeleton created by ChatGPT
//  V0.2.0  2026-01-02  Documentation, start of debugging
//  V0.2.1  2026-01-05  Changed LidarDecoder.h and cpp to L2lidar
//                      Changed class name from LidarDecoder to L2lidar
//                      Added L2 information to GUI
//                      Added L2 start rotation, stop rotation,
//                              reset and get Version info buttons
//                      Changed config dialog
//                          for src and dest ip, port
//                      Updated @notes for unitree_lidar_protocols.h
//  V0.2.2  2026-01-07  Added ACK packets decodes to ui
//          2026-01-08  Added Mutex access to packet copies
//                      Added 3d point packet to 3d PCL cloud conversion
//                          to demonstrate packets are being received
//                          and processed correctly
//  V0.2.3  2026-01-08  Added point cloud viewer
//                      updated PC stats
//  V0.2.4  2026-01-10  Started add of Calibration and internal State dialog
//                      Started add of set work mode dialog
//                      Changed OpenGL approach to add coloring
//                      Added SkipFrame settings for point cloud display
//  V0.2.5  20260-01-12 Start of mainwindow GUI reorg
//                      Added heartbeat timer to update some of the
//                      dockable uis
//                      Added IMU dockable window
//                      Added ACK dockable window
//                      Added packet stats dockable window
//                      Added Calib and internal state dockable window
//
//--------------------------------------------------------

//--------------------------------------------------------
// This uses the following Unitree L2 sources modules:
//      unitree_lidar_protocol.h
//      unitree_lidar_utilities
// The orignal source can be found at:
//      https://github.com/unitreerobotics/unilidar_sdk2
//      under License: BSD 3-Clause License (see files)
//
// Corrections/additions have been made to these 2 files
//--------------------------------------------------------

//--------------------------------------------------------
// GPL-3.0 license
//
// This file is part of L2diagnsotic.
//
// L2diagnsotic is free software : you can redistribute it and /or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// L2diagnsotic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with L2diagnsotic.
// If not, see < https://www.gnu.org/licenses/>.
//--------------------------------------------------------


//--------------------------------------------------------
// Main project includes required before anything else
//--------------------------------------------------------
#include "MainWindow.h"
#include "unitree_lidar_protocol.h"
#include "unitree_lidar_utilities.h"

//--------------------------------------------------------
// Autogenerated Qt desktop GUIM include
// This is generated from the MainWindow.ui file
// The CMakeFIle.txt must include:
//      set(CMAKE_AUTOMOC ON)
//      set(CMAKE_AUTOUIC ON)
//      set(CMAKE_AUTORCC ON)
//--------------------------------------------------------
#include "ui_MainWindow.h"
#include "PointCloudWindow.h"

//--------------------------------------------------------
//  Qt includes
//--------------------------------------------------------
#include <QHostAddress>
#include <QDateTime>
#include <QSettings>
#include <QStandardPaths>
#include <QDebug>

//--------------------------------------------------------
//  Project specific includes not part of MainWindow.h
//--------------------------------------------------------
// #include "ConfigDialog.h"

//--------------------------------------------------------
//  MainWIndow class constructor
//--------------------------------------------------------
MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //--------------------------------------------------------
    //  setup the dockable data guis
    //--------------------------------------------------------

    //--------------------------------------------------------
    //  This timer is used to trigger updates
    //  for Diagnostics, IMU and Stats
    //--------------------------------------------------------

    mHeartBeat = new QTimer(this);
    mHeartBeat->setInterval(250); // 4 Hz

    connect(mHeartBeat, &QTimer::timeout, this, &MainWindow::HeartbeatFire);

    //--------------------------------------------------------
    //  setup the dockable diagnsotics gui
    //--------------------------------------------------------
    m_diagnosticsDock = new DiagnosticsDock(this);
    addDockWidget(Qt::RightDockWidgetArea, m_diagnosticsDock);
    m_diagnosticsDock->hide();   // start hidden
    resizeDocks({ m_diagnosticsDock },{ 220 },Qt::Horizontal);

    //--------------------------------------------------------
    //  setup dockable packet Stats gui
    //--------------------------------------------------------
    m_StatsDock = new StatsDock(this);
    addDockWidget(Qt::LeftDockWidgetArea, m_StatsDock);
    m_StatsDock->hide();   // start hidden
    resizeDocks({ m_StatsDock },{ 220 },Qt::Horizontal);

    //--------------------------------------------------------
    //  setup dockable IMU gui
    //--------------------------------------------------------
    m_IMUDock = new IMUDock(this);
    addDockWidget(Qt::LeftDockWidgetArea, m_IMUDock);
    m_IMUDock->hide();   // start hidden
    resizeDocks({ m_IMUDock },{ 220 },Qt::Horizontal);

    //--------------------------------------------------------
    //  setup dockable ACK gui (this is not timer driven)
    //  It is event driven.  ACKs are extermely low rate events
    //--------------------------------------------------------
    m_ACKDock = new ACKDock(this);
    addDockWidget(Qt::TopDockWidgetArea, m_ACKDock);
    m_ACKDock->hide();   // start hidden

    connect(&l2lidar,
            &::L2lidar::ackReceived,
            this,
            &MainWindow::updateACK,
            Qt::QueuedConnection);

    //--------------------------------------------------------
    //  setup the Main window GUI
    //--------------------------------------------------------

    //--------------------------------------------------------
    //  Chart view gui
    //--------------------------------------------------------
    // GUI utlizes the chart timer to update the GUI
    // from stored memory so that it does not block I/O

    // Setup chart GUI elements
    auto chart = new QChart();
    rateSeries = new QLineSeries();
    chart->addSeries(rateSeries);

    auto axisX = new QValueAxis();
    auto axisY = new QValueAxis();
    axisX->setRange(0, 100); // 100 smaples
    axisY->setRange(0, 1000); // 0-1000 packets per second
    chart->addAxis(axisX, Qt::AlignBottom);
    chart->addAxis(axisY, Qt::AlignLeft);
    rateSeries->attachAxis(axisX);
    rateSeries->attachAxis(axisY);

    auto chartView = new QChartView(chart);
    chartView->setRenderHint(QPainter::Antialiasing);
    ui->verticalLayout->addWidget(chartView);

    // Chart update timer
    // The chart timer is started/stopped by start and stop GUI buttons
    connect(&chartTimer, &QTimer::timeout, this, &MainWindow::updateChart);

    //--------------------------------------------------------
    //  Connect UI buttons
    //--------------------------------------------------------

    connect(ui->btnStart, &QPushButton::clicked, this, &MainWindow::L2connect);
    connect(ui->btnStop, &QPushButton::clicked, this, &MainWindow::L2disconnect);
    connect(ui->btnConfig, &QPushButton::clicked, this, &MainWindow::openConfig);

    connect(ui->btnStartRotation, &QPushButton::clicked, this, &MainWindow::startRotation);
    connect(ui->btnStopRotation, &QPushButton::clicked, this, &MainWindow::stopRotation);
    connect(ui->btnResetL2, &QPushButton::clicked, this, &MainWindow::sendReset);
    connect(ui->btnVersion, &QPushButton::clicked, this, &MainWindow::getVersion);

    //--------------------------------------------------------
    //  setup point cloud viewer GUI
    //--------------------------------------------------------
    pcWindow = new PointCloudWindow(this);
    pcWindow->hide();       // show when L2 start is called

    // point cloud viewer connections
    connect(&l2lidar,
            &::L2lidar::PCL3DReceived,
            this,
            &MainWindow::onNewLidarFrame,
            Qt::QueuedConnection);

    connect(this,
            &MainWindow::flattenedCloudReady,
            pcWindow->view(),
            &PointCloudView::setPointCloud,
            Qt::QueuedConnection);

    // setup timer for point cloud updating
    cloudTimer = new QTimer(this);
    cloudTimer->setInterval(33); // 30 Hz
    connect(cloudTimer,
            &QTimer::timeout,
            this,
            &MainWindow::updatePointCloud);

    // 3D point cloud viewer buffering
    m_frameRing.resize(MAX_FRAMES); // ring buffer pre allocated

    // Load previously saved user settings
    loadSettings();
    NumFramesToSkip = config.getSkipFrame();

    // load the com parameters in the l2lidar class
    l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                              config.getDSTip(),config.getDSTport());

    // initial state of buttons and uis is L2 disconnected
    L2DisconnectedButtonsUIs(); // set buttons and UIs states when L2 disconnected
}

//--------------------------------------------------------
//  MainWIndow class destructor
//--------------------------------------------------------
MainWindow::~MainWindow()
{
    // delete timers and window docks
    // if(!m_diagTimer) delete m_diagTimer;
    // if(!m_diagnosticsDock) delete m_diagnosticsDock;

    // Make sure live capture is stopped
    L2disconnect();

   // Save current user settings
    saveSettings();

    delete ui;
}

//--------------------------------------------------------
//
//  helper functions
//
//--------------------------------------------------------

//--------------------------------------------------------
//  L2DisconnectedButtonsUIs
//--------------------------------------------------------
void MainWindow::L2ConnectedButtonsUIs()
{ // set buttons and UIs states when L2 disconnected
    // disable start, enable stop
    ui->btnStart->setEnabled(false);
    ui->btnStop->setEnabled(true);
    ui->btnStartRotation->setEnabled(true);
    ui->btnStopRotation->setEnabled(true);
    ui->btnResetL2->setEnabled(true);
    ui->btnVersion->setEnabled(true);

    // show diagnostics, IMU and stats window
    // these update at the heartbeat rate
    m_diagnosticsDock->show();
    m_IMUDock->show();
    m_StatsDock->show();
    mHeartBeat->start();

    // ACK window is event driven, on ACK packet receive
    m_ACKDock->show();

    // start point cloud viewer
    StartPointCloudViewer();

}

//--------------------------------------------------------
//  L2ConnectedButtonsUIs
//--------------------------------------------------------
void MainWindow::L2DisconnectedButtonsUIs()
{ // set buttons and UIs states when L2 connected
    ui->btnStart->setEnabled(true);
    ui->btnStop->setEnabled(false);
    ui->btnStartRotation->setEnabled(false);
    ui->btnStopRotation->setEnabled(false);
    ui->btnResetL2->setEnabled(false);
    ui->btnVersion->setEnabled(false);

    // turn off point cloud viewer
    StopPointCloudViewer();

    // turn off docks
    mHeartBeat->stop();
    m_diagnosticsDock->hide();
    m_IMUDock->hide();
    m_StatsDock->hide();

    // turn off ACK, this is event drive
    // it is very low rate
    m_ACKDock->hide();
}

//--------------------------------------------------------
//  StartPointCloudViewer
//--------------------------------------------------------
void MainWindow::StartPointCloudViewer()
{
    cloudTimer->start();
    pcWindow->show();
}

//--------------------------------------------------------
//  StopPointCloudViewer
//--------------------------------------------------------
void MainWindow::StopPointCloudViewer()
{
    cloudTimer->stop();
    pcWindow->hide();
}

//--------------------------------------------------------
//
//  Dockable windows
//
//  timer driven separate GUI windows from main GUI window
//
//--------------------------------------------------------

void MainWindow::HeartbeatFire()
{
    updateDiagnostics();
    updateIMU();
    updateStats();
    return;
}

//--------------------------------------------------------
//  updateStats
//--------------------------------------------------------
void MainWindow::updateStats()
{
    // update detailed packet stats
    uint64_t countPackets = l2lidar.totalPackets();
    uint64_t lostPackets = l2lidar.lostPackets();
    uint64_t count3DPCL = l2lidar.total3D();
    uint64_t count2DPCL = l2lidar.total2D();
    uint64_t countIMU = l2lidar.totalIMU();
    uint64_t countACK = l2lidar.totalACK();
    uint64_t countOther = l2lidar.totalOther();
    LidarTimeStampData TimeStamp = l2lidar.timestamp();
    m_StatsDock->updateStats(
                TimeStamp.data.sec,
                TimeStamp.data.nsec,
                countPackets,
                count3DPCL,
                count2DPCL,
                countIMU,
                countACK,
                countOther,
                lostPackets
                );

    return;
}

//--------------------------------------------------------
//  updateDiagnostics
//--------------------------------------------------------
void MainWindow::updateDiagnostics()
{
    LidarVersionData Version = l2lidar.version();
    LidarPointDataPacket PCLpacket = l2lidar.Pcl3Dpacket();

    m_diagnosticsDock->updateDiagnostics(PCLpacket.data.state, PCLpacket.data.param);
    m_diagnosticsDock->updateVersion(Version);

    return;
}

//--------------------------------------------------------
//  updateIMU
//--------------------------------------------------------
void MainWindow::updateIMU()
{
    LidarImuData Imu = l2lidar.imu();


    m_IMUDock->updateIMU(Imu);

    return;
}

//--------------------------------------------------------
//  updateACK, event driven not timer driven
//--------------------------------------------------------
void MainWindow::updateACK()
{
    LidarAckData ACKdata = l2lidar.ack();
    m_ACKDock->updateACK(ACKdata);

    return;
}

//--------------------------------------------------------
//
//  Point cloud viewer data generator
//
//  timer driven separate GUI window from main GUI window
//
//--------------------------------------------------------

//--------------------------------------------------------
//  onNewLidarFrame()
//  signal recieved from l2lidar class that a new frame
//  of point cloud data is availabe
//  This removes the oldest frame from the fifo if the fifo
//  is full and and adds the new frame to the fifo
//  for display
//
//  This is updated at the packet receive rate
//
//--------------------------------------------------------
void MainWindow::onNewLidarFrame()
{
    // skip packet logic to reduce load
    // skip 0 take severy packet
    // skip 1 takes every other packet
    // skip 2 takes every 3rd packet
    // ...
    // ...
    static uint64_t frameCounter = 0;

    if (NumFramesToSkip > 0 &&
        (++frameCounter % (NumFramesToSkip + 1)) != 0)
    {
        return;
    }

    // Retrieve packet
    auto packet = l2lidar.Pcl3Dpacket();

    unilidar_sdk2::PointCloudUnitree cloud;
    unilidar_sdk2::parseFromPacketToPointCloud(
        cloud, packet, false, 0, 100);

    Frame frame;
    frame.reserve(cloud.points.size());

    for (const auto& p : cloud.points)
    {
        frame.push_back({
            p.x,
            p.y,
            p.z,
            p.intensity,
            p.time,
            p.ring
        });
    }


    QMutexLocker lock(&m_cloudMutex);

    // Overwrite oldest frame in-place
    m_frameRing[m_ringWrite] = std::move(frame);

    m_ringWrite = (m_ringWrite + 1) % MAX_FRAMES;
    if (m_ringCount < MAX_FRAMES)
        ++m_ringCount;
}

//--------------------------------------------------------
//  updatePointCloud()
//  timer driven emitter for point cloud viewer
//  The acculated frames are flattened and sent
//  to the viewer at the viewer display rate
//  This timer set and started in L2connect()
//--------------------------------------------------------
void MainWindow::updatePointCloud()
{
    auto cloud = buildFlattenedCloud();
    if (!cloud.isEmpty())
        emit flattenedCloudReady(cloud);
}


//--------------------------------------------------------
//  buildFlattenedCloud()
//  help function that converts the frame fifo
//  into a flattened point cloud array
//--------------------------------------------------------
QVector<PCpoint> MainWindow::buildFlattenedCloud()
{
    QVector<Frame> localFrames;

    {
        QMutexLocker lock(&m_cloudMutex);

        if (m_ringCount == 0)
            return {};

        const size_t oldest =
            (m_ringWrite + MAX_FRAMES - m_ringCount) % MAX_FRAMES;

        localFrames.reserve(m_ringCount);
        for (size_t i = 0; i < m_ringCount; ++i) {
            size_t idx = (oldest + i) % MAX_FRAMES;
            localFrames.push_back(m_frameRing[idx]); // shallow copy
        }
    } // mutex released here

    // Now flatten WITHOUT holding the mutex
    QVector<PCpoint> PCcloud;
    size_t totalPoints = 0;
    for (const auto& f : localFrames)
        totalPoints += f.size();

    PCcloud.reserve(totalPoints);
    for (const auto& f : localFrames)
        PCcloud += f;

    return PCcloud;
}


//--------------------------------------------------------
//
//  GUI mainwindow
//  button presses
//
//--------------------------------------------------------

//--------------------------------------------------------
//  openConfig
//  button press
//
//  open the configuration dialog to allow the user to change
//  application settings.
//--------------------------------------------------------
void MainWindow::openConfig()
{
    if (config.exec() == QDialog::Accepted) {
        l2lidar.LidarSetCmdConfig(config.getSRCip(),config.getSRCport(),
                                  config.getDSTip(),config.getDSTport());
        NumFramesToSkip = config.getSkipFrame();
        saveSettings();
    }
}

//--------------------------------------------------------
//  L2connect()
//  button press
//--------------------------------------------------------
void MainWindow::L2connect()
{
    //
    if(!l2lidar.ConnectL2()) {
        qWarning() << "Failed: coudl open open communications port to L2";
        return;
    }

    LastRateCount = 0; // reset rate count

    // Start chart timer
    chartTimer.start(CHART_UPDATE_TIMER);

    L2ConnectedButtonsUIs();
}

//--------------------------------------------------------
//  L2disconnect()
//  button press
//--------------------------------------------------------
void MainWindow::L2disconnect()
{
    chartTimer.stop();

    // close UDP connection for receiving data
    l2lidar.DisconnectL2();

    l2lidar.ClearCounts();
    recentRates.clear(); // clear the rate history

    L2DisconnectedButtonsUIs();
}

//--------------------------------------------------------
//  startRotation
//  button press
//--------------------------------------------------------
void MainWindow::startRotation()
{
    l2lidar.LidarStartRotation();
    return;
}

//--------------------------------------------------------
//  stopRotation
//  button press
//--------------------------------------------------------
void MainWindow::stopRotation()
{
    l2lidar.LidarStopRotation();
    return;
}

//--------------------------------------------------------
//  sendReset
//  button press
//--------------------------------------------------------
void MainWindow::sendReset()
{
    l2lidar.LidarReset();
    return;
}

//--------------------------------------------------------
//  getVersion
//  button press
//--------------------------------------------------------
void MainWindow::getVersion()
{
    l2lidar.LidarGetVersion();
    return;
}

//--------------------------------------------------------
//
// timer driven update of main window GUI
//
//--------------------------------------------------------

//--------------------------------------------------------
//  updateChart()
//  update the user GUI with latest I/O results
//--------------------------------------------------------
void MainWindow::updateChart()
{
    // update detailed packet stats
    uint64_t countPackets = l2lidar.totalPackets();

    uint64_t RateCount;
    uint64_t RatePerSec;

    // update the packet rate chart

    // calculate packets per second
    RateCount = countPackets;
    // ??? save the timestamp with each rate sample
    //  calculate rate using delta timestamp
    // this would result in a rate not subject to GUI interactions
    RatePerSec = (RateCount - LastRateCount)*1000/CHART_UPDATE_TIMER;
    LastRateCount = RateCount; // save for next timer timer

    // save RatesPerSec for graph
    recentRates.push_back(RatePerSec);
    if (recentRates.size() > maxPoints)
        recentRates.pop_front();

    rateSeries->clear();
    int x = 0;
    for (auto value : recentRates)
        rateSeries->append(x++, static_cast<qreal>(value));

    // update general packet stats
    ui->lblRate->setText(QString("Rate: %1 pkt/s").arg(RatePerSec));

    return;
}
